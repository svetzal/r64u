# Commodore D64, D71, and D81 Disk Image Technical Specification

This document describes the **D64** , **D71** , and **D81** disk image formats as used by Commodore 8-bit systems (e.g., C64, C128). It covers the disk geometry, Block Availability Map (BAM) structure, directory layout, file storage method, file types, and the key differences between these formats. The goal is to provide a clear technical reference for implementing C++ code to read (and eventually write) these disk images.

## Disk Geometry and Capacity

Each Commodore disk image format defines a set of _tracks_ and _sectors_ per track that mirror the layout of the original floppy disk:

- **D64** – Represents a single-sided 5¼" 1541 disk (170 KB nominal). It uses 35 tracks by default (with optional extension up to 40 or 42 tracks in some images). The disk uses **zone-bit recording** , meaning outer tracks have more sectors than inner ones [[1]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Note%20that%20tracks%20at%20the,non%20standard) . On a standard 35-track D64:
- Tracks 1–17 have 21 sectors each
- Tracks 18–24 have 19 sectors each
- Tracks 25–30 have 18 sectors each
- Tracks 31–35 have 17 sectors each _(Tracks 36–40 (or 42) are non-standard extensions, usually 17 sectors each, if present_ [*[2]*](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Tracks%201..17%20,non%20standard) _.)_ Each sector is 256 bytes. A 35-track D64 contains 683 sectors total [[3]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=format%20optionally%20features%20an%20additional,does%20not%20require%20special%20software) [[4]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Track%20%201%20,256) , of which 683 – 19 = **664 sectors are usable for files** on a newly formatted disk (19 sectors on track 18 are reserved for directory and BAM) [[5]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,sector%201) [[6]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=As%20per%20the%20previous%20section%2C,track%20is%20in%20the%20middle) . This yields “664 blocks free” on an empty D64. Maximum directory entries per disk is 144 (explained in Directory section). An unextended D64 file size is 174,848 bytes (683 * 256) with no error bytes [[7]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Currently%20there%20are%20four%20different,D64%20formats) . Optional error bytes (one per sector) can expand it to 175,531 bytes [[7]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Currently%20there%20are%20four%20different,D64%20formats) .
- **D71** – Represents a double-sided 5¼" 1571 disk (basically two D64 sides in one image). It doubles the capacity of D64 without changing the per-track layout. A 1571-formatted disk has 70 tracks (35 per side) with the same sectors-per-track as D64 on each side [[8]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%201571%20disk%20drive%20uses,sectors%20on%20each%20track%20is) . The D71 image is essentially **two D64 images concatenated** (side 1 followed by side 2) [[9]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Comparing%20this%20to%20the%20Layout,D64%20images%20glued%20together) . Total sectors ~1366 (2 * 683), and an empty disk has **1328 usable blocks free** – exactly double a D64’s 664 [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) . Notably, the directory remains limited to 144 entries (the same as D64) because Commodore DOS kept a single directory track (track 18 of side 1) for the whole disk [[11]](https:/petlibrary.tripod.com/D71.HTM#:~:text=,the%20next%20track%2Fsector%20of) [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) . (In other words, the second side doesn’t introduce a second directory; see Differences section.) A standard D71 image file is 349,696 bytes (1366 * 256) if no error info is included.
- **D81** – Represents a 3½" 1581 disk (800 KB nominal). The 1581 uses a different physical format (MFM encoding with 80 cylinders, double-sided), but the D81 image presents a logical layout of **80 tracks** (often called “80 logical tracks” [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) ). Each logical track has 40 _256-byte sectors_ [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) . (Internally, the 1581 achieves this by using 10 physical 512-byte sectors per track and treating each half as a 256-byte logical sector [[13]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=1581%20is%20similar%20enough%20to,failure%20rate%3B%20the%20problem%20was) [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) .) Tracks are numbered 1–80 (with tracks 1–40 on side 1 and 41–80 on side 2 logically). All tracks have a uniform 40 sectors. This gives 80 * 40 = 3200 sectors total, of which 3200 – 40 = **3160 are free for file storage** on a blank disk [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) . (Track 40 is reserved for directory and BAM as detailed below, accounting for 40 sectors overhead.) The 1581 format allows up to **296 directory entries** (far more than D64’s 144) by dedicating more sectors to the directory [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) . A D81 image file is 819,200 bytes (3200 * 256) without error data.

**Summary of Geometry:** All three formats use 256 bytes per sector logically. D64 and D71 have variable sectors per track (zone recording), whereas D81 has a fixed 40 sectors/track. The table below summarizes key geometry details:

| **Format**     | **Tracks**  (sides)      | **Sectors per Track**                                | **Total Sectors**   | **Free Blocks**  (formatted)   |
|----------------|--------------------------|------------------------------------------------------|---------------------|--------------------------------|
| D64 (35-track) | 35 (single-sided)        | 21 (trk 1–17); 19 (18–24); 18 (25–30); 17 (31–35)[1] | 683                 | 664[5][6]                      |
| D71            | 70 (35 tracks × 2 sides) | Same as D64 on each side (tracks 36–70 mirror 1–35)  | ~1366               | 1328[10]                       |
| D81            | 80 (double-sided)        | 40 sectors on every track[12]                        | 3200                | 3160[14]                       |

## Block Availability Map (BAM) and Disk Header

The **Block Availability Map (BAM)** tracks which disk blocks (sectors) are free or in use. It is stored in a fixed location on each disk type, alongside the disk header (which contains the disk name, ID, and DOS type version). The BAM is essentially a bitmap of the disk's sectors, organized by track.

- **D64 BAM and Header:** In a 1541 disk, the BAM and header reside in **Track 18, Sector 0** [[5]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,sector%201) . This 256-byte sector contains:
- **Disk Header:** The first few bytes include a pointer to the first directory sector and the disk’s identification. Byte $00–$01 store the track and sector of the first directory sector (usually 18 and 1) [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) . If the directory occupies more than one sector, this pointer links to the next sector in the directory chain; if no further directory sectors, it is $00/$FF (track $00 and sector $FF) to signify end-of-directory [[15]](https:/petlibrary.tripod.com/D71.HTM#:~:text=,the%20next%20track%2Fsector%20of) . The disk DOS version/type is stored in a header byte as well (for 1541-format disks this is typically the ASCII "2A" in the disk ID field, meaning DOS 2, format variant A). The Disk Name and Disk ID are stored in this sector as text. On 1541 disks, the disk name is 16 characters padded with $A0 (PETSCII space) and typically begins at offset $90 within sector 18/0 [[16]](https:/github.com/Larswad/uno2iec/blob/master/d64driver.cpp#:~:text=...%2018%20,disk%20name%20padded) . The two-byte disk ID follows, and a 2-byte DOS type field (for example "2A" or "3D", etc.) identifies the format/version [[17]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=%2400%E2%80%9301%20T%2FS%20reference%20to%20first,3D) .
- **BAM Entries:** Following the header info, the BAM uses a fixed-size bitfield for each track. For a standard D64 (35 tracks), there are 35 entries. Each track’s entry is 4 bytes: the first is the **free sector count** (number of free sectors on that track), followed by a 3-byte bitmap marking each sector’s availability [[18]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=,BAM) [[19]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Track%2018%20,the%20disk%20id%20is%20stored) . Each bit in the bitmap corresponds to a sector (bit = 1 means **free** , 0 means used) on that track. The 3 bytes (24 bits) are enough to cover up to 21 sectors (with a few bits unused for tracks with fewer than 21 sectors). For example, track 1’s BAM entry (bytes $04–$07 in 18/0) gives the count of free sectors on track 1 and a 21-bit map of which of its sectors are free [[18]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=,BAM) . The DOS updates this map as files are saved or deleted. Track 18 itself is marked as largely occupied (its directory sectors are not free). On a newly formatted disk, the BAM’s free count totals 664 and all non-reserved sectors bits are set to 1 (free).
- **D71 BAM and Header:** A D71 image simply doubles the D64 layout, so it effectively has two BAMs: one for each side. **Track 18, Sector 0** (the first side’s BAM) contains the disk header and BAM for tracks 1–35 (side 1) just as in D64 [[20]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,Sector%201) . Additionally, **Track 53, Sector 0** (which corresponds to track 18 of side 2, since track numbering continues to 53 for side 2 track 18) holds the BAM for tracks 36–70 (the second side) [[20]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,Sector%201) . The disk name/ID in the header is only stored on the primary BAM (18/0); the side-B BAM at 53/0 primarily contains the free block bitmap for side 2. The directory pointer in 18/0 still points to track 18/1 (on side 1) and the directory entries for the entire disk reside on side 1 (the 1571 DOS does **not** utilize a second directory track on side 2) [[15]](https:/petlibrary.tripod.com/D71.HTM#:~:text=,the%20next%20track%2Fsector%20of) [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) . Thus, track 53 sector 0 is used for BAM data and the **rest of track 53’s sectors are free for file storage** [[21]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=Post%20%20%20by%20,Sep%2023%2C%202011%204%3A44%20am) . The BAM structure (4 bytes per track entry) is the same as D64, except it covers 70 tracks (split across the two BAM sectors).
- **D81 BAM and Header:** The 1581 uses a more spacious directory/BAM track. **Track 40** is dedicated as the _directory track_ [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) . The disk header resides in **track 40, sector 0** , and the BAM spans the next two sectors (40,1 and 40,2) [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) [[22]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=%2400%E2%80%9301%20T%2FS%20reference%20to%20first,3D) . In the 1581 header sector (40/0), bytes $00–$01 point to the first directory sector (track 40, sector 3) [[23]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) . The DOS version byte is $44 ('D' for DOS 3.0+) at $02, followed by a $00 byte [[24]](http:/www.unusedino.de/ec64/technical/formats/d81.html#:~:text=D81%20,Track%2FSector%20location%20of%20next) . The disk name is stored from byte $04 for 16 bytes, padded with $A0, with two $A0 bytes following it as separator [[25]](http:/www.unusedino.de/ec64/technical/formats/d81.html#:~:text=,Track%2FSector%20location%20of%20next) . Bytes $16–$17 hold the disk ID, and bytes $19–$1A contain the DOS type ID (for a 1581, this is typically "3D" meaning double-sided DOS 3) [[17]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=%2400%E2%80%9301%20T%2FS%20reference%20to%20first,3D) . The **BAM sectors** (40/1 and 40/2) contain the free-block bitmaps. Because the 1581 has 80 tracks, the BAM cannot fit in one 256-byte block. Instead, it is split across two sectors. The first BAM sector (40/1) contains a header and the bitmap for tracks 1–40, and the second (40/2) continues with tracks 41–80 [[26]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=19%E2%80%931A%20DOS%20type%20) [[27]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=06%20I%2FO%20byte%2007%20Autoboot,BAM%20entries%20for%20Tracks%2041%E2%80%9380) . Each BAM sector begins with a pointer to the next BAM sector (40/1’s first two bytes point to 40/2, and 40/2’s pointer is $00/$FF indicating end of BAM chain) [[28]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=BAM%20Contents%2C%2040%2F1) . After a DOS version and disk ID repetition, the actual BAM bitmaps start at offset $10 in each BAM sector [[29]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=BAM%20Contents%2C%2040%2F1) . The format of each track’s BAM entry is slightly different in 1581: because each track has 40 sectors, a track’s bitmap uses 5 bytes (40 bits) plus possibly a count. The 1581 DOS also supports _partitioning_ and subdirectories, but in a standard D81 image the BAM simply marks free blocks globally. A freshly formatted 1581 shows **3160 blocks free** and up to 296 entries free in the directory [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) .

**Note:** In all formats, the BAM (and directory) is always stored on a dedicated track (track 18 for D64/D71, track 40 for D81). This central location was chosen to minimize the average seek distance for directory access [[6]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=As%20per%20the%20previous%20section%2C,track%20is%20in%20the%20middle) . The disk name and ID are purely informational for the user/program and for distinguishing disks; they do not affect the file data structure except as labels.

## Directory Structure and Directory Entries

Commodore disks use a single _flat directory_ (no subfolders except in 1581’s special partition mode) that contains metadata for each file. The directory is stored in a linked list of sectors on the designated directory track.

- **Directory Track and Sector Chain:** On 1541/1571 disks, **track 18** holds the directory. The directory begins at **track 18, sector 1** (since 18/0 is BAM) [[5]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,sector%201) . Additional directory sectors (18/2, 18/3, etc., up to 18/??) are linked as needed if the directory has more than 8 entries. Each directory sector uses the first two bytes as a pointer to the next directory sector (track and sector). For example, track 18 sector 1’s first two bytes point to track 18 sector 2 if the directory continues, or $00/$FF if it is the last directory sector [[11]](https:/petlibrary.tripod.com/D71.HTM#:~:text=,the%20next%20track%2Fsector%20of) . The end-of-directory is marked by the special pointer track = 0 and sector = $FF [[11]](https:/petlibrary.tripod.com/D71.HTM#:~:text=,the%20next%20track%2Fsector%20of) . A newly formatted D64/D71 has track 18 sector 1 allocated as the first (and initially only) directory block, and its pointer bytes set to $00/$FF (no further sectors). On a D71, **only side 1’s track 18** is used for directory entries (max 18 sectors); the DOS did _not_ implement a second directory on side 2 [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) . On a 1581, the directory starts at **track 40, sector 3** [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) and continues through sector 39 of track 40 if needed. Since track 40 has 40 sectors (3 of which are used for header/BAM), there are **37 sectors available for directory entries** on a D81 [[30]](https:/ist.uwaterloo.ca/~schepers/formats/D81.TXT#:~:text=D81%20The%20directory%20track%20should,Block%20Availability%20Map) . These are linked similarly via pointers in the first two bytes of each sector. In total, the 1581 directory track can hold up to 37 * 8 = 296 file entries [[30]](https:/ist.uwaterloo.ca/~schepers/formats/D81.TXT#:~:text=D81%20The%20directory%20track%20should,Block%20Availability%20Map) [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) .
- **Directory Sector Format:** Each directory sector is 256 bytes and is conceptually divided into 8 _entries_ of 32 bytes each (8 entries * 32 = 256). However, as noted, the first two bytes of _each sector_ are taken by the forward-pointer to the next sector. To accommodate this while keeping entries a consistent size, **each 32-byte entry has 2 unused bytes** at its start (essentially padding) [[31]](https:/c64os.com/post/sd2iecfilenames#:~:text=Each%20256,can%20those%20first%202%20bytes) [[32]](https:/c64os.com/post/sd2iecfilenames#:~:text=To%20account%20for%20this%2C%20the,became%20a%20de%20facto%20standard) . In the first entry of a sector, those 2 bytes are actually used for the sector link (next track/sector); in the remaining 7 entries of that sector, the 2-byte padding is just $00 $00 (unused) [[33]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Here%2C%20each%20entry%20uses%2030,byte%20groups%20inside%20a%20sector) [[34]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%200%20and%201%3A%20So,can%20be%20seen%20as%20padding) . This design means every directory entry effectively uses 30 bytes for actual information, and 2 bytes per entry (16 bytes per sector in total) are wasted as padding [[35]](https:/c64os.com/post/sd2iecfilenames#:~:text=and%20sector%20of%20the%20next,bytes%20are%20already%20spoken%20for) . Thus, each directory sector holds at most 8 entries, and the maximum files on a D64 or D71 disk is 144 (18 sectors * 8) [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) . The 1581, with 37 directory sectors, allows up to 296 entries [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) .
- **Directory Entry Format:** Each file’s metadata occupies one 32-byte entry (with 30 meaningful bytes as described). The layout of a directory entry is as follows (offsets are within the entry, where offset 0 of an entry is the first byte of that 32-byte slot; note that offsets 0–1 of each entry are not used for file data except when an entry happens to be the first in a sector, in which case those bytes are the directory chain pointer):

| **Offset**   | **Size**   | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|--------------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 0–1          | 2 bytes    | **Unused in directory entry**  (or next-sector pointer if this entry is at the start of a sector). These bytes are $00 $00 for normal entries (and also $00 $00 in the first entry once its pointer is moved to the sector header area). They serve only as padding to maintain 32-byte alignment  [[33]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Here%2C%20each%20entry%20uses%2030,byte%20groups%20inside%20a%20sector)  .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 2            | 1 byte     | **File Type byte**  – Encodes the file’s type and attributes. The lower 3 bits indicate the file type (0 = DEL, 1 = SEQ, 2 = PRG, 3 = USR, 4 = REL, 5 = GEOS  _VLIR_  or HDR, 6 =  _DIR_  (subdirectory, 1581/CMD only), etc.)  [[36]](https:/www.pagetable.com/?p=1038#:~:text=Commodore%20Peripheral%20Bus%3A%20Part%203%3A,The%20mode%20byte)  [[37]](https:/vice-emu.sourceforge.io/vice_17.html#:~:text=File%20or%20partition%20size%20in,field%20is%20used%20as)  . The high bits are flags: bit 7 = file closed flag (1 if closed properly, 0 if still open or “splat” – shown as * in directory)  [[38]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%202%20is%20the%20file,closed)  [[39]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Bit%207%20indicates%20a%20closed,should%20be%20interpreted%20as%20follows)  ; bit 6 = lock flag (1 if locked/protected, shown as &lt; in directory)  [[40]](https:/c64os.com/post/sd2iecfilenames#:~:text=The%20second%20highest%20bit%20is,This%20feels%20like%20a)  [[41]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Bit%206%20indicates%20replacement%20which,closed)  ; bit 5 =  _replace flag_  (used internally during save-with-replace, a temporary state)  [[42]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Bit%207%20indicates%20a%20closed,closed)  . A normal closed file will have bit 7 = 1 and bit 6 = 0 (unless locked) in this byte. The file type nybble is typically interpreted only if the file is closed (bit7=1)  [[38]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%202%20is%20the%20file,closed)  . For example, a PRG file byte might be $82 (1000 0010b: closed=1, locked=0, type=2/PRG), whereas an open incomplete PRG might be $02 (0000 0010b, indicating the *PRG state). |
| 3            | 1 byte     | **Track of first file block**  – The track number where the first sector of the file’s data is located  [[43]](https:/c64os.com/post/sd2iecfilenames#:~:text=All%20of%20that%20is%20packed,byte%20of%20a%20directory%20entry)  [[38]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%202%20is%20the%20file,closed)  . If this is 0, the file is considered “splat” or scratched (or the entry is unused).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 4            | 1 byte     | **Sector of first file block**  – The sector number on the above track for the file’s start. Together, the track and sector tell DOS where to begin reading the file’s contents  [[43]](https:/c64os.com/post/sd2iecfilenames#:~:text=All%20of%20that%20is%20packed,byte%20of%20a%20directory%20entry)  . If both track and sector are 0, the directory entry is a deleted file (DEL) entry or an uninitialized entry.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 5–20         | 16 bytes   | **Filename in PETSCII**  – Commodore filenames can be up to 16 characters. If the name is shorter, the remaining bytes are filled with $A0 (PETSCII shift-space, which appears as blank padding)  [[44]](https:/c64os.com/post/sd2iecfilenames#:~:text=)  [[45]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%203%20and%204%3A%20This,first%20sector%20in%20the%20file)  . The characters are typically in PETSCII (uppercase by default on C64). No separate extension is stored; the file type is indicated by the Type byte instead. (Note: GEOS and some systems use ASCII in filenames which can appear as mixed-case in a C64 listing, but the disk still just stores raw bytes here  [[46]](https:/c64os.com/post/sd2iecfilenames#:~:text=)  .)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 21           | 1 byte     | **Rel file side-track**  – Used  *only for RELative files*  . If the file type is REL, this byte stores the track number of the file’s  *side-sector chain*  (which contains the record index for the REL file). For non-REL files, this byte is normally 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 22           | 1 byte     | **Rel file side-sector**  – (REL files only) Sector number of the start of side-sector chain. For other file types, 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 23           | 1 byte     | **Rel file record length**  – (REL files only) The length of each record in the file, in bytes (1–254). This tells DOS how to calculate record positions. Non-REL entries set this to 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 24–28        | 5 bytes    | **Reserved / used for disk-specific purposes**  – On Commodore’s 1541/1571 DOS, these bytes are not used for standard files (they may be written as 0). In 1581 and CMD hard disk DOS, some of these bytes are used to store a  **timestamp**  (Creation date/time: year, month, day, hour, minute)  [[47]](https:/c64os.com/post/sd2iecfilenames#:~:text=)  . Specifically, CMD DOS uses bytes 24–28 for timestamp, since the 1541/71 didn’t use them  [[48]](https:/c64os.com/post/sd2iecfilenames#:~:text=The%20following%205%20bytes%20are,DOS%20to%20hold%20the%20timestamp)  . If timestamps are unused, these may remain 0 or $FF.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 29–30        | 2 bytes    | **File size in sectors (little-endian)**  – This is a 16-bit count of the number of  _blocks_  (sectors) used by the file  [[37]](https:/vice-emu.sourceforge.io/vice_17.html#:~:text=File%20or%20partition%20size%20in,field%20is%20used%20as)  [[49]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%2030%20and%2031%3A%20This,File%20will%20still)  . This value is what gets shown in the disk directory listing as the file’s size (in “blocks”).  **Important:**  This is a purely informational field and is not automatically updated to reflect exact byte counts; it normally equals the total sectors allocated to the file. The DOS uses it for display, but does not rely on it for reading the file contents  [[49]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%2030%20and%2031%3A%20This,File%20will%20still)  . In fact, it can be manually altered without affecting the actual file data – the true end-of-file is determined by the file’s block chain and the final block’s used-byte count, not by this directory field  [[49]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%2030%20and%2031%3A%20This,File%20will%20still)  .                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |

**Directory entry example:** For instance, a closed, unlocked PRG file might have a Type byte of $82 (binary 1000 0010b: bits 0-2 = 010 (PRG), bit7=1 closed, bit6=0 unlocked) in offset 2 [[38]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%202%20is%20the%20file,closed) . If its first data block is at track 12 sector 5, bytes 3–4 would be $0C $05. Bytes 5–20 would contain the PETSCII filename padded with $A0. If it’s not REL, bytes 21–23 would be 0. Suppose it used 5 sectors of storage, then bytes 29–30 would be $05 $00 (5 blocks). If the file’s last block was not completely full, the exact byte count can be inferred only by reading the last block (see File Storage below).

## File Storage and Sector Allocation

File data on Commodore disks is stored in 256-byte sectors, with a filesystem-level linked list to handle file fragmentation and length. The disk format supports several file types (SEQ, PRG, etc.), but all (except REL) use a similar sequential block chain. Key aspects of file storage:

- **Data Block Structure:** Each 256-byte sector that belongs to a file is structured with a 2-byte **forward pointer** followed by 254 bytes of data. The first byte of a data sector is the track number of the next sector in the file; the second byte is the sector number of the next sector in the file [[50]](https:/c64os.com/post/sd2iecfilenames#:~:text=directory%20blocks%20do,254) . These two bytes act as a link to the next block in the chain, very much like a linked list pointer. This means out of 256 bytes per sector, only 254 are available for file data payload [[50]](https:/c64os.com/post/sd2iecfilenames#:~:text=directory%20blocks%20do,254) . If a file spans multiple sectors, each sector points to the next in sequence. The sectors need not be contiguous on the disk; DOS will allocate the first free block it finds, which could be anywhere, and link it in.
- **End-of-File Block:** The last sector of a file is indicated by a special pointer value. Instead of pointing to another sector, the track byte is set to 0 to mark end-of-file. In CBM DOS, the convention for the **final block** is: **Track = $00** and the **sector byte = number of data bytes used in this last sector** [[51]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=A%20file%20,there%20if%20you%20want%20to) [[52]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Commodore%2064%20disk%20drive%20programming,bytes%20used%20in%20the%20sector) . For example, if the last sector of a file contains 80 bytes of useful data, the pointer bytes will be $00 $50 (where $50 = 80 in decimal). If a file ends exactly on a sector boundary using the full 254 bytes of the last block, the pointer would be $00 $FE (254 decimal) to indicate that 254 bytes are used in that final block [[51]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=A%20file%20,there%20if%20you%20want%20to) . (Note: $FF as the sector byte in an end-of-file pointer is not used for files; $FF in the sector pointer is used in directory blocks instead. For files, sector byte $00 would never appear since 0 bytes used is not a valid condition when a block is allocated – a file that is a multiple of 254 bytes would still be marked with $FE = 254 used in the last block.) The file’s exact byte length can thus be determined by reading the second byte of the final block’s header. All preceding blocks of the file will have non-zero track links pointing to the next block.
- **File Data and Loading:** For **PRG (program) files** , the first two data bytes of the _first_ sector are typically a load address (little-endian). This is part of the file’s content, not a filesystem construct – the DOS doesn’t treat it specially except that when the C64 loads a PRG, it will set the starting memory address from these first two bytes. So in a PRG’s first sector, after the two link bytes, you’ll see two bytes of load address, then actual program data. That means the first data sector of a PRG has 2 (link) + 2 (load address) + 252 (program data) = 256 bytes in total [[53]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=then%20the%20sector%20value%20is,there%20if%20you%20want%20to) . Sequential (SEQ) and user (USR) files have no such standardized header in the data; they are just streams of bytes.
- **Interleaving:** Commodore DOS employs a default _sector interleave_ when writing files to reduce rotational latency. For example, on a 1541, when writing a file sequentially, it might allocate sectors in an order like 0, 3, 6,… rather than 0,1,2,… on a track [[54]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=One%20could%20also%20mention%20that,to%20fix%20that%20now%20%E2%80%A6) . This gives the drive time to read the next block in one rotation. The exact interleave (skipping pattern) differs by drive type (commonly 10 for 1541, etc.), and is a low-level detail not affecting the logical image structure. When parsing a disk image, files can be read by following the track/sector links; the physical order on track is not sequential but the link chain provides the correct order.
- **REL file structure:** Relative files (REL) use a more complex scheme to allow record-based random access. In addition to the main data block chain (which can be non-sequential order of records), a REL file has _side sectors_ that contain a lookup table of record pointers. The directory entry for a REL file (bytes 21–23 as described) gives the starting track/sector of the side-sector chain and the record length [[38]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%202%20is%20the%20file,closed) . Each side sector contains an index of pointers to data sectors for specific record ranges. When implementing REL file support, you must read the side-sector table to find the correct data block for a given record number. The exact format: each side-sector can hold up to 120 pointers (they are 2 bytes each for track and sector, minus some header) and covers a range of record numbers; multiple side sectors may be chained if the file is large. REL files are relatively rare and somewhat tricky (Commodore DOS 2.x supports them fully, but many third-party devices do not implement REL writing). For initial directory extraction, it’s enough to identify them by type. Eventually, supporting REL reads/writes means implementing the pointer table logic.
- **File Allocation and Deletion:** When a file is deleted (scratched), the DOS simply marks its directory entry as type DEL (and usually sets the first track/sector pointer to 0/0) and frees its sectors in the BAM. The sectors themselves are not wiped; they still contain the old data until overwritten. The directory entry remains but will not be shown in a normal listing (unless the type is intentionally left as DEL for a visible "deleted" entry placeholder). The filesystem does not coalesce free space – it relies on the BAM to find free blocks. When writing a new file, DOS scans the BAM for the next available block (usually starting from track 1 onward). As a result, files can end up fragmented across the disk, but since each block has a pointer to the next, fragmentation doesn’t impede sequential reading beyond extra seek time.

## File Types and Metadata

Commodore files have several types indicated by the directory. The primary **file types** and their interpretations are:

- **DEL** (Deleted): A pseudo-type indicating a directory entry that is to be treated as deleted. Normally, these entries do not appear in directory listings (unless one intentionally views them via disk editors). DEL files have no allocated blocks (track/sector pointer is usually 0/0). However, some people creatively use DEL entries for Easter eggs or separators in directory art because the entry can contain a “filename” that still shows up if forced, but the DOS ignores it. In the directory entry, DEL is represented by type code 0 (with bit7 usually 0 since it’s not a valid open file either) [[55]](http:/www.6502.org/users/andre/petindex/drives/local/drive_info.txt#:~:text=drive_info.txt%20,USR%2C%20R%20%3D) [[37]](https:/vice-emu.sourceforge.io/vice_17.html#:~:text=File%20or%20partition%20size%20in,field%20is%20used%20as) .
- **SEQ** (Sequential): A generic sequential file, typically used for data (text files, etc.). Type code 1 (binary 001 with bit7=1 for closed). These are not loadable by the BASIC LOAD command (unless you open via secondary address), but can be read in a program via sequential I/O. Internally, stored just like PRG (no special header in data).
- **PRG** (Program): The standard program file type, code 2 (binary 010). This is any file intended to be loaded into computer memory and potentially executed. The first two data bytes of the file are taken as the load address for the program in memory. For example, many BASIC programs have a load address of $0801. After loading, the BASIC or machine code program can be run. PRG files can also be used for any binary data that should be loadable at a specific address.
- **USR** (User): Type code 3 (011). Meant for user-defined purposes. In practice, GEOS (a Commodore GUI OS) used USR files in a special way (VLIR format: basically a user file with its own internal structure of multiple segments). Outside of GEOS, USR files are not common, and the DOS treats them similarly to SEQ in terms of storage.
- **REL** (Relative): Type code 4 (100). A relative-record file, supporting fixed-length records with random access by record number. The DOS implements this by using the extra pointer table (side sectors) as discussed. REL files are fairly uncommon in typical usage (they were intended for database-like applications). The directory entry stores the record length and starting side sector. When reading or writing a REL file, a program uses special DOS commands to seek to a record number; the DOS then uses the side-sector index to locate the correct data block. Writing C++ code to fully support REL is a bit involved – one must parse the side sectors.
- **Others:** Commodore’s DOS **2.x** (1541/1571) did not formally define more types beyond the above five. However, with the 1581 (DOS 3.1) and later third-party systems, two additional types came into play:
- **CBM** or **Vendor-specific** (type 5 or 6): The 1581 and CMD hard drives introduced a **DIR** type for subdirectories (in partitions) and a **partition descriptor** type. In some references, type 5 (101) is used for GEOS VLIR header files or partitions, and type 6 (110) for _DIR_ (a directory entry that points to a subdirectory on a CMD device or 1581 partition) [[56]](https:/c64os.com/c64os/usersguide/filemanager#:~:text=Choose%20a%20file%20type%20,includes%20entries%20of%20that%20type) . These might appear as "CBM" or "DIR" in some tools. They are not used on 1541/1571 disks because those don’t support subdirectories. In a D81 image, if partitions are not used, you typically won’t see these either, except possibly GEOS disks which use type 5 for the VLIR header file paired with USR for the data file.
- **“Unknown”/Reserved (type 7)** : Binary 111 might be reserved or unused. On some systems this could conceivably tag something like a batch (not standard). Generally, you won’t encounter type 7 in normal scenarios.

The **file type byte in the directory** is mainly for human interpretation (and for DOS to refuse certain operations, e.g., you cannot LOAD a SEQ file without specifying ,8, etc.). The DOS does not substantially differentiate how it stores PRG vs SEQ vs USR – all are sequential file chains. The type flags (locked, etc.) are enforced in that DOS will not allow deletion of a locked file without unlocking it, for example [[40]](https:/c64os.com/post/sd2iecfilenames#:~:text=The%20second%20highest%20bit%20is,This%20feels%20like%20a) .

**Locked files:** As mentioned, bit 6 of the type byte indicates the file is locked (protected) [[40]](https:/c64os.com/post/sd2iecfilenames#:~:text=The%20second%20highest%20bit%20is,This%20feels%20like%20a) . Such a file can be loaded or read, but the DOS will prevent it from being scratched (deleted) or overwritten unless explicitly overridden. In a directory listing on a Commodore machine, locked files are shown with a &lt; symbol appended to the file type abbreviation (e.g., PRG&lt; means a locked PRG file).

**Open/"splat" files:** If a file was not properly closed (for example, due to resetting the computer during a save), its directory entry retains bit 7 = 0, indicating an unclosed file. In a disk listing this is shown by an * preceding the file type (the infamous "splat"). Such a file often has an incorrect block count in the directory (since it wasn’t finalized) and typically a dangling last sector pointer. The file can usually still be read (the DOS will treat end-of-file when it hits an invalid pointer). Copying the file or saving it again will clear the condition. The * is simply a visual warning in the directory listing that the file may be incomplete [[57]](https:/c64os.com/post/sd2iecfilenames#:~:text=is%20just%20an%20indicator%20that,ability%20to%20close%20it%20properly) [[58]](https:/c64os.com/post/sd2iecfilenames#:~:text=The%20second%20highest%20bit%20is,a%20bug%20to%20me%2C%20frankly) .

**Disk name and ID:** Not a file, but for completeness: The disk name (16 chars) and disk ID (2 chars) stored in the BAM header can be read by the DOS command HEADER or by reading track 18 (or 40 on 1581) directly. They serve to label the disk and the ID is used by the DOS to detect disk swaps (the DOS stores the ID of the last accessed disk to know if you changed disks without telling it). The DOS type field (e.g., "2A", "3D") is typically fixed for the format. In a directory listing (when you do $), the name and ID are printed at the top, followed by the list of files.

## Differences and Commonalities Between D64, D71, and D81

Finally, to summarize the key differences and similarities of these formats:

- **Physical vs Logical Structure:** All three formats store a linear sequence of 256-byte sectors representing the disk’s logical blocks (excluding any optional error bytes) [[59]](https:/www.c64-wiki.com/wiki/D64#:~:text=The%20D64%20file%20itself%20is,made%20to%20read%20that%20sector) . There is no additional metadata in the file – the format is recognized by file size or context [[60]](https:/www.c64-wiki.com/wiki/D64#:~:text=As%20there%20is%20no%20magic,the%20file%20name%20and%20size) . D64 and D71 correspond to GCR-encoded 5¼" media (1541/1571) and use a _zone-based varying sectors-per-track_ layout [[1]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Note%20that%20tracks%20at%20the,non%20standard) . D81 corresponds to MFM 3½" media (1581) with uniform sectors-per-track [[13]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=1581%20is%20similar%20enough%20to,failure%20rate%3B%20the%20problem%20was) . However, when working with the images at a filesystem level, the differences in encoding don’t matter – one simply treats them as sector arrays per the geometry above.
- **Disk Capacity:** A standard D64 holds 170 KB of data (excluding error bytes). A D71 doubles that (~349 KB) by including a second side’s data back-to-back [[9]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Comparing%20this%20to%20the%20Layout,D64%20images%20glued%20together) . A D81 holds about 800 KB [[61]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=1987%2C%20primarily%20for%20its%20C64,operators%20and%20other%20users) [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) . The number of usable file blocks on a freshly formatted disk is 664 for D64, 1328 for D71 (not 1329 or more – the second side’s directory track is unused for files, but its sectors except sector 0 are actually free, yielding exactly double D64’s count) [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) [[21]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=Post%20%20%20by%20,Sep%2023%2C%202011%204%3A44%20am) , and 3160 for D81 [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) .
- **Directory Limits:** D64 and D71 can hold at most 144 files in the root directory, since they have one directory track with 8 entries * 18 sectors [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) . D71 does _not_ increase the directory size, as the second side’s track 18 is not used for additional entries (Commodore DOS 3.0 for the 1571 simply mirrored the single-sided directory structure for simplicity) [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) . The D81 format increased the directory track space to allow 296 entries (on a single track 40) [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) . Notably, the 1581 (and CMD hard drives) also allow the concept of subdirectories (using special directory files of type "DIR"), but a D81 image by itself typically represents a single partition (with one directory). Subdirectories, if used, would consume an entry and have their own blocks allocated (1581 supports partitions as separate directories accessible via changing default partition or working directory commands).
- **BAM Differences:** In D64/D71, the BAM is compact enough to fit (for 35 or 70 tracks) in a single sector (or two) along with the header. D64 uses 1 BAM sector (track 18/0). D71 uses 2 (18/0 for side1, 53/0 for side2) but duplicates the concept per side [[20]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,Sector%201) . D81 uses 3 sectors (track 40 sectors 0-2) to cover 80 tracks [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) . Functionally, all BAMs serve the same role: bitmaps of free blocks. A minor difference: the 1541/1571 BAM also stores the _number_ of free sectors per track (the first byte of each 4-byte track entry) which is redundant but handy for DOS (it avoids counting bits each time) [[18]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=,BAM) . The 1581’s BAM likely also includes free counts or can compute from the bits (the 1581 DOS can handle much larger disks, and its data structures are a bit different, e.g., it supports up to 80 tracks and multiple partitions).
- **Error Bytes:** All formats optionally support an error code table appended to the image. If present, it is one byte per sector in the image, in the same order as the sectors. For a 35-track D64, that is 683 error bytes. D71 with errors would have 1366 error bytes, D81 would have 3200. These error bytes record physical disk errors (CRC errors, etc.) that were present on the source disk when imaged [[62]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20,does%20not%20require%20special%20software) [[63]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Code%20%20Error%20%20Type,Write%20%20Write%20verify%20error) . An error byte of 0x01 (No error) is normal [[63]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Code%20%20Error%20%20Type,Write%20%20Write%20verify%20error) . Non-zero codes represent things like data checksum error, header not found, etc., as per the 1541 error codes [[63]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Code%20%20Error%20%20Type,Write%20%20Write%20verify%20error) . In most emulator use-cases, error bytes are not needed unless one is preserving intentionally bad disk protections. For building a filesystem parser, you can safely ignore error bytes or just ensure to skip them when reading the image (by knowing the file size vs expected size without errors).
- **Interoperability:** A 1571 drive can read D64 (1541) disks and indeed the D71 format was chosen to be just an extension of D64. The directory structure and BAM of a D71 are the same as D64’s, so the 1571 DOS remains backward compatible with the 1541’s assumptions [[64]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=Lemon64%20www,track%20on%20the%20other) . The 1581’s DOS is more advanced (different low-level encoding, support for partitions, and a different BAM layout) and not backward compatible at the drive level with 1541/1571 disks – however, the high-level file system concepts (directory entries, file chains) remain very similar, just scaled up [[65]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%20version%20of%20Commodore%20DOS,The%20number%20of%20permitted) [[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) . From a software perspective, parsing D64 or D71 is almost identical (just account for the double size and second BAM), while parsing D81 requires accommodating a different directory track number and reading the BAM from two sectors. After that, interpreting directory entries and file chains is the same process for all three.
- **Example Sizes and IDs:** A blank D64 directory listing typically shows 664 BLOCKS FREE., and a disk ID like 2A (which actually appears next to the disk name in the header). A blank D71 would show 1328 BLOCKS FREE. (and still one disk name/ID, since it's one logical volume). A blank D81 shows 3160 BLOCKS FREE., and the DOS type in the header is usually 3D (the D might appear in the disk ID line, indicating DOS 3.1 double-sided format). These identifiers are mostly informational but are a quick way to recognize the format of a disk in an emulator or DOS prompt.

In summary, **D64** is the baseline single-sided format with well-known limitations (144 files, 664 blocks). **D71** simply doubles capacity but otherwise stays within the same design (no extra directory capacity). **D81** significantly expands capacity and directory size, and introduces subdirectory capability (though not often used in .D81 images unless dealing with multiple partitions or CMD FD drives). All three share the fundamental 1541 file system structure: BAM + single directory + file block chains with 254-byte payloads. By using the information in this specification – track layouts, BAM handling, directory entry parsing, and file block linking – a developer can implement code to navigate directory listings and read file contents from any of these image types. Subsequent features like writing files or handling REL file random access can be added on top of this solid foundation.

**References:**

- 1541/1571 Disk structure and D64 format [[1]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Note%20that%20tracks%20at%20the,non%20standard) [[66]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,sector%201) [[6]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=As%20per%20the%20previous%20section%2C,track%20is%20in%20the%20middle)
- D71 format (double-sided 1571 disk) details [[9]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Comparing%20this%20to%20the%20Layout,D64%20images%20glued%20together) [[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) [[21]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=Post%20%20%20by%20,Sep%2023%2C%202011%204%3A44%20am)
- 1581/D81 disk format and layout [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) [[67]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2)
- BAM and Directory locations on each format [[66]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,sector%201) [[20]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,Sector%201) [[67]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2)
- Directory entry format and file type flags [[33]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Here%2C%20each%20entry%20uses%2030,byte%20groups%20inside%20a%20sector) [[38]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%202%20is%20the%20file,closed) [[43]](https:/c64os.com/post/sd2iecfilenames#:~:text=All%20of%20that%20is%20packed,byte%20of%20a%20directory%20entry)
- File block chaining and end-of-file markers [[50]](https:/c64os.com/post/sd2iecfilenames#:~:text=directory%20blocks%20do,254) [[51]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=A%20file%20,there%20if%20you%20want%20to)
- Discussion of directory structure and reserved bytes [[35]](https:/c64os.com/post/sd2iecfilenames#:~:text=and%20sector%20of%20the%20next,bytes%20are%20already%20spoken%20for) [[49]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%2030%20and%2031%3A%20This,File%20will%20still)

[[1]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Note%20that%20tracks%20at%20the,non%20standard) [[2]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Tracks%201..17%20,non%20standard) [[3]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=format%20optionally%20features%20an%20additional,does%20not%20require%20special%20software) [[4]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Track%20%201%20,256) [[5]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,sector%201) [[7]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Currently%20there%20are%20four%20different,D64%20formats) [[8]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%201571%20disk%20drive%20uses,sectors%20on%20each%20track%20is) [[9]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Comparing%20this%20to%20the%20Layout,D64%20images%20glued%20together) [[20]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,Sector%201) [[62]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20,does%20not%20require%20special%20software) [[63]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=Code%20%20Error%20%20Type,Write%20%20Write%20verify%20error) [[66]](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html#:~:text=The%20Block%20Allocation%20Map%20,sector%201) Power64 Documentation - File Formats

[https://www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File\_Formats.html](https:/www.infinite-loop.at/Power64/Documentation/Power64-ReadMe/AE-File_Formats.html)

[[6]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=As%20per%20the%20previous%20section%2C,track%20is%20in%20the%20middle) [[18]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=,BAM) [[19]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Track%2018%20,the%20disk%20id%20is%20stored) [[33]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Here%2C%20each%20entry%20uses%2030,byte%20groups%20inside%20a%20sector) [[34]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%200%20and%201%3A%20So,can%20be%20seen%20as%20padding) [[38]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%202%20is%20the%20file,closed) [[39]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Bit%207%20indicates%20a%20closed,should%20be%20interpreted%20as%20follows) [[41]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Bit%206%20indicates%20replacement%20which,closed) [[42]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Bit%207%20indicates%20a%20closed,closed) [[45]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%203%20and%204%3A%20This,first%20sector%20in%20the%20file) [[49]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Byte%2030%20and%2031%3A%20This,File%20will%20still) [[51]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=A%20file%20,there%20if%20you%20want%20to) [[52]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=Commodore%2064%20disk%20drive%20programming,bytes%20used%20in%20the%20sector) [[53]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=then%20the%20sector%20value%20is,there%20if%20you%20want%20to) [[54]](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/#:~:text=One%20could%20also%20mention%20that,to%20fix%20that%20now%20%E2%80%A6) Commodore 64 disk drive programming – Bergatrollet's Tech Blog

[http://bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming/](http:/bergatrollet.se/blog/2019/08/commodore-64-disk-drive-programming)

[[10]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=I%20just%20thought%20of%20something,made%20it%20hold%20288%20files) [[21]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=Post%20%20%20by%20,Sep%2023%2C%202011%204%3A44%20am) [[64]](https:/www.lemon64.com/forum/viewtopic.php?t=39560#:~:text=Lemon64%20www,track%20on%20the%20other) Number of files per disk/disk image? - Commodore 64 - Lemon64 - Commodore 64

[https://www.lemon64.com/forum/viewtopic.php?t=39560](https:/www.lemon64.com/forum/viewtopic.php?t=39560)

[[11]](https:/petlibrary.tripod.com/D71.HTM#:~:text=,the%20next%20track%2Fsector%20of) [[15]](https:/petlibrary.tripod.com/D71.HTM#:~:text=,the%20next%20track%2Fsector%20of) *** D71 (Electronic form of a double-sided 1571 disk)

[https://petlibrary.tripod.com/D71.HTM](https:/petlibrary.tripod.com/D71.HTM)

[[12]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) [[13]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=1581%20is%20similar%20enough%20to,failure%20rate%3B%20the%20problem%20was) [[14]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=for%20fast%20disk%20access%2C%20but,emulation%20mode) [[17]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=%2400%E2%80%9301%20T%2FS%20reference%20to%20first,3D) [[22]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=%2400%E2%80%9301%20T%2FS%20reference%20to%20first,3D) [[23]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) [[26]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=19%E2%80%931A%20DOS%20type%20) [[27]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=06%20I%2FO%20byte%2007%20Autoboot,BAM%20entries%20for%20Tracks%2041%E2%80%9380) [[28]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=BAM%20Contents%2C%2040%2F1) [[29]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=BAM%20Contents%2C%2040%2F1) [[61]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=1987%2C%20primarily%20for%20its%20C64,operators%20and%20other%20users) [[65]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%20version%20of%20Commodore%20DOS,The%20number%20of%20permitted) [[67]](https:/en.wikipedia.org/wiki/Commodore_1581#:~:text=The%201581%20disk%20has%2080,resides%20on%2040%2F1%20and%2040%2F2) Commodore 1581 - Wikipedia

[https://en.wikipedia.org/wiki/Commodore\_1581](https:/en.wikipedia.org/wiki/Commodore_1581)

[[16]](https:/github.com/Larswad/uno2iec/blob/master/d64driver.cpp#:~:text=...%2018%20,disk%20name%20padded) uno2iec/d64driver.cpp at master · Larswad/uno2iec · GitHub

[https://github.com/Larswad/uno2iec/blob/master/d64driver.cpp](https:/github.com/Larswad/uno2iec/blob/master/d64driver.cpp)

[[24]](http:/www.unusedino.de/ec64/technical/formats/d81.html#:~:text=D81%20,Track%2FSector%20location%20of%20next) [[25]](http:/www.unusedino.de/ec64/technical/formats/d81.html#:~:text=,Track%2FSector%20location%20of%20next) D81 (Electronic form of a physical 1581 disk) - unusedino.de

[http://www.unusedino.de/ec64/technical/formats/d81.html](http:/www.unusedino.de/ec64/technical/formats/d81.html)

[[30]](https:/ist.uwaterloo.ca/~schepers/formats/D81.TXT#:~:text=D81%20The%20directory%20track%20should,Block%20Availability%20Map) D81

[https://ist.uwaterloo.ca/~schepers/formats/D81.TXT](https:/ist.uwaterloo.ca/~schepers/formats/D81.TXT)

[[31]](https:/c64os.com/post/sd2iecfilenames#:~:text=Each%20256,can%20those%20first%202%20bytes) [[32]](https:/c64os.com/post/sd2iecfilenames#:~:text=To%20account%20for%20this%2C%20the,became%20a%20de%20facto%20standard) [[35]](https:/c64os.com/post/sd2iecfilenames#:~:text=and%20sector%20of%20the%20next,bytes%20are%20already%20spoken%20for) [[40]](https:/c64os.com/post/sd2iecfilenames#:~:text=The%20second%20highest%20bit%20is,This%20feels%20like%20a) [[43]](https:/c64os.com/post/sd2iecfilenames#:~:text=All%20of%20that%20is%20packed,byte%20of%20a%20directory%20entry) [[44]](https:/c64os.com/post/sd2iecfilenames#:~:text=) [[46]](https:/c64os.com/post/sd2iecfilenames#:~:text=) [[47]](https:/c64os.com/post/sd2iecfilenames#:~:text=) [[48]](https:/c64os.com/post/sd2iecfilenames#:~:text=The%20following%205%20bytes%20are,DOS%20to%20hold%20the%20timestamp) [[50]](https:/c64os.com/post/sd2iecfilenames#:~:text=directory%20blocks%20do,254) [[57]](https:/c64os.com/post/sd2iecfilenames#:~:text=is%20just%20an%20indicator%20that,ability%20to%20close%20it%20properly) [[58]](https:/c64os.com/post/sd2iecfilenames#:~:text=The%20second%20highest%20bit%20is,a%20bug%20to%20me%2C%20frankly) Understanding SD2IEC Filenaming | C64 OS

[https://c64os.com/post/sd2iecfilenames](https:/c64os.com/post/sd2iecfilenames)

[[36]](https:/www.pagetable.com/?p=1038#:~:text=Commodore%20Peripheral%20Bus%3A%20Part%203%3A,The%20mode%20byte) Commodore Peripheral Bus: Part 3: Commodore DOS

[https://www.pagetable.com/?p=1038](https:/www.pagetable.com/?p=1038)

[[37]](https:/vice-emu.sourceforge.io/vice_17.html#:~:text=File%20or%20partition%20size%20in,field%20is%20used%20as) 17 The emulator file formats - VICE Manual

[https://vice-emu.sourceforge.io/vice\_17.html](https:/vice-emu.sourceforge.io/vice_17.html)

[[55]](http:/www.6502.org/users/andre/petindex/drives/local/drive_info.txt#:~:text=drive_info.txt%20,USR%2C%20R%20%3D) drive\_info.txt - 6502.org

[http://www.6502.org/users/andre/petindex/drives/local/drive\_info.txt](http:/www.6502.org/users/andre/petindex/drives/local/drive_info.txt)

[[56]](https:/c64os.com/c64os/usersguide/filemanager#:~:text=Choose%20a%20file%20type%20,includes%20entries%20of%20that%20type) File Manager - User's Guide | C64 OS

[https://c64os.com/c64os/usersguide/filemanager](https:/c64os.com/c64os/usersguide/filemanager)

[[59]](https:/www.c64-wiki.com/wiki/D64#:~:text=The%20D64%20file%20itself%20is,made%20to%20read%20that%20sector) [[60]](https:/www.c64-wiki.com/wiki/D64#:~:text=As%20there%20is%20no%20magic,the%20file%20name%20and%20size) D64 - C64-Wiki

[https://www.c64-wiki.com/wiki/D64](https:/www.c64-wiki.com/wiki/D64)
