Commodore 64 PRG File Format Specification

Overview of the PRG Format

The PRG file is the standard format for storing executable programs on the Commodore 64 (and its 8-bit family). It is a very simple binary format consisting of a small header followed by raw program data. In fact, this is the exact same format the C64 uses to save programs to disk or tape ￼. PRG files typically carry the .prg extension (sometimes .C64 in certain emulator contexts) and can be loaded directly by emulators or transferred onto a disk image for use on real hardware ￼.

A PRG file begins with a 2-byte little-endian load address, which tells the C64 where in memory to load the subsequent bytes ￼ ￼. Everything after these two bytes is the actual program code or data, laid out exactly as it should appear in the C64’s RAM when loaded ￼. There is no additional metadata, checksums, or formatting beyond this; the PRG is essentially a raw memory dump with just the starting address prepended ￼.

Default Addresses: By convention, many C64 PRG files (especially those containing BASIC programs) use a start address of $0801 (2049 decimal) ￼. This is the beginning of BASIC program memory on the C64. For example, if you write a BASIC program on a C64 and SAVE it, the resulting PRG will start at $0801. However, the format allows any 16-bit address from $0000–$FFFF. Machine language programs often use other load addresses depending on where they need to reside in memory. Common choices are addresses in the “upper memory” (for instance, $C000) or even $0801 with a small BASIC stub to auto-start the code. The PRG format itself does not distinguish the program’s type – it could be a BASIC program, machine code routine, or even arbitrary data meant to be loaded into memory. The load address simply dictates where the bytes will be placed in RAM.

File Structure of a .PRG File

A Commodore 64 PRG file’s layout can be broken down into two parts: a 2-byte header for the load address, and the program data that follows. The structure is as follows:
	•	Load Address (2 bytes): A 16-bit little-endian address indicating the start memory location where the program data should be loaded ￼. The first byte is the low-order 8 bits and the second byte is the high-order 8 bits of the address. For example, the byte sequence 0x01 0x08 in a PRG file corresponds to the address $0801 (since 0x01 is the low byte and 0x08 the high byte) ￼. This address is not part of the program’s code itself; it serves as metadata for the loader. When the C64 loads a PRG (using the LOAD command with the “,1” flag for binary load), the KERNAL will read this 2-byte value to know where in RAM to place the subsequent data ￼. These header bytes are not loaded into memory – only the bytes after them are loaded at the specified address ￼. (In other words, the file’s third byte will end up at memory address LoadAddress on the C64, the fourth byte at LoadAddress+1, and so on ￼.)
	•	Program Data (remaining bytes): This is the raw binary data of the program, exactly as it should appear in memory once loaded ￼. There is no additional header or footer around this data in a standard PRG. It’s essentially a memory dump that the C64 will copy into RAM starting at the load address ￼. The length of this segment can vary widely – from just a few bytes to tens of kilobytes – up to the limits of the C64’s address space and storage medium. The format does not include an explicit length field; the end of file implicitly marks the end of the data.

Interpreting the Program Data: The contents of the program data depend on what the PRG represents, but the format does not enforce any specific structure here (aside from how the C64 will interpret it when running). For example, if the PRG contains a Commodore BASIC program, the data section will be a sequence of tokenized BASIC lines (each line prefixed by a pointer to the next line and a line number, and ending with a zero byte) starting at $0801. If the PRG contains machine code, the data section will be a sequence of 6502/6510 opcodes and data bytes arranged to be loaded at the given address. The PRG file itself makes no distinction – it simply delivers these bytes into memory. It is up to the user or running environment to know how to execute or use the loaded data. (As a hint, a BASIC program PRG almost always starts at $0801, whereas a machine code PRG might start at an address like $C000 or might include a BASIC bootstrap at $0801 that uses a SYS call to jump into the machine code.) The key point is that the PRG format is agnostic to the content – it only ensures the bytes end up at the correct address in RAM.

Example: Suppose we have a very simple BASIC program with one line, saved as a PRG. On disk, the file might look like this in hex: 01 08 ... 0A 00 9E 20 32 30 36 34 00 00 00 (as in the example below). Here 0x01 0x08 is the load address $0801 ￼ ￼. The bytes following it (...) represent the BASIC line in tokenized form (in this case, the line is 10 SYS 2064, which in memory is stored as $0801: 0C 08 (pointer to next line), 0A 00 (line number 10), 0x9E (token for SYS), 0x20 0x32 0x30 0x36 0x34 (the characters " 2064"), 0x00 (end of line), $080C: 00 00 (pointer indicating end of program) etc.) ￼. When the C64 loads this file, it sees the load address $0801 and copies the remaining bytes into memory starting at $0801, reconstructing the BASIC program in memory. If instead the PRG were a machine code program with a load address of, say, $C000, the first two bytes might be 00 C0 and the following bytes would be the actual machine code intended to reside at $C000. In all cases, the mechanism is the same: read the 2-byte address, then load the rest of the file’s bytes into RAM starting at that address.

Variants and Related Formats

While the .PRG format described above is the most direct representation of a Commodore 64 program file, there are a few variants and related formats commonly encountered in the C64 community. These mainly involve adding simple headers or using different file extensions for compatibility with various platforms and emulators, without changing the fundamental content structure.

Raw PRG vs. “C64” Extension

Some platforms or tools use the extension .C64 for program files, but this is not a different format – it’s essentially the same as a standard .PRG file. In other words, a .C64 file contains the same 2-byte load address followed by program bytes described above ￼ ￼. The different extension is used mostly for clarity or association (for example, on macOS with certain emulators, .C64 might denote a C64 program file). Regardless of extension, the file’s internal structure remains “load address + data” as defined for PRGs.

PC64 Single-File Container (.P00 and friends)

A very common variant is the “P00” format, which originates from early PC-to-C64 transfer tools and emulators (notably PC64 by Wolfgang Lorenz). A .P00 file is essentially a PRG file wrapped with a 26-byte header to provide additional metadata (like a recognizable signature and the original Commodore filename) ￼ ￼. This was useful on platforms (like MS-DOS) that had limitations on filenames and needed to preserve the C64’s file names and types. The P00 format allows emulators to verify file integrity via a magic number and to know the intended Commodore filename of the program ￼ ￼. It is one of a family of “PC64” container formats for single files, where the file extension encodes the Commodore file type (e.g. .P00 for PRG files, .S00 for sequential files, .U00 for user files, .R00 for relative files) ￼ ￼. The “00” in the extension can increment (01, 02, etc.) if needed to differentiate files when multiple files would otherwise have the same DOS name ￼ ￼.

Structure of a .P00 File: The P00 file begins with an 8-byte magic constant followed by a fixed-length header, then the actual program data:
	•	Magic Constant (8 bytes): ASCII string "C64File" followed by a zero byte. In hexadecimal, this is { 0x43, 0x36, 0x34, 0x46, 0x69, 0x6C, 0x65, 0x00 } which corresponds to the text “C64File”� ￼ ￼. This signature identifies the file as a PC64 single-file container.
	•	Original Filename (17 bytes): The next 17 bytes store the original Commodore filename of the program, in Commodore’s CBM (PETSCII) encoding ￼. Commodore filenames can be up to 16 characters, so this field provides 16 bytes for the name plus one byte as a terminator. In the P00 format, the filename is padded with 0x00 bytes if shorter than 16 characters (unlike Commodore disk directories which use 0xA0 spaces for padding) ￼. The 17th byte of this field is typically a 0x00 terminator (it is “always $00” at byte $18 of the header) ￼, ensuring the string is null-terminated. This allows the emulator or tool to display the file’s original C64 name exactly as it would appear on a disk directory (including case or PETSCII graphics characters, since PETSCII is used).
	•	Record Size (1 byte): Following the filename, there is a single byte intended for REL file record length ￼. This field is only meaningful if the file is a RELative file (a special type of random-access file on Commodore DOS). In a .R00 file, this byte stores the record length in bytes for that relative file. In all other cases (for PRG, SEQ, or USR types), this byte is set to 0x00 ￼. For a PRG-type P00, you can consider this field unused (it will be 0).
	•	Program Data (variable): After the 26-byte header (8 + 17 + 1 bytes discussed above), the rest of the file consists of the actual data of the Commodore file ￼. In the case of a .P00 that represents a PRG, this data segment starts with the same 2-byte load address and program bytes that a normal .PRG file would contain. Essentially, the P00 wraps a standard PRG file’s content. For example, if you have a normal PRG file and convert it to P00, you would take the original PRG’s two-byte load address and all following bytes and place them starting at offset $1A in the P00 file. The presence of the header does not alter the program data itself. The emulator or tool reading the P00 will recognize the “C64File” signature, extract the original name (for display or matching), skip the header, and then load the remaining bytes exactly as a .PRG ￼.

In summary, P00 = 26-byte header + raw PRG data. The total file length of a P00 will therefore be 26 bytes larger than the length of the equivalent PRG. This format was recommended for single-file transfers by some documentation because the magic number can prevent confusion or invalid files from being loaded by mistake ￼ ￼. Today, most modern emulators and tools can handle raw .PRG files directly (and .P00 has become less common), but you may still encounter P00 files in archives or older collections. If you do, remember that the original C64 filename and file type are embedded in the header, which can be useful information.

Other Related Formats: Aside from P00, there are a couple of other notable formats for storing C64 programs, though they are not variants of the PRG file structure but rather alternative containers or contexts:
	•	Tape Images (TAP/T64): These formats (.TAP and .T64) were used to represent cassette tape data. A .T64 file is a pseudo-tape image with a directory that can contain one or more files (each entry includes a load address and length, among other things), whereas a .TAP is a raw dump of tape pulses. If a program is stored in a T64, that file’s data will include the equivalent of a PRG (load address + data) along with tape-specific header info. T64 and TAP, however, are beyond the scope of a single PRG file spec – they are more like archives or disk images for tape media.
	•	Disk Images (D64/D71/D81/etc.): In a disk image (like .D64 for 1541 disks), program files are stored as blocks of data on the virtual disk. The directory entry in a D64 stores the file type (PRG, SEQ, etc.) and track/sector pointers, but not the load address explicitly. The load address is actually part of the file’s first two bytes on disk as well ￼. So if you extract a PRG from a D64 image, you’ll get the same two-byte header and data. The D64 itself isn’t a different format for the file; it’s a container holding the file. Therefore, whether a PRG comes from a disk image or as a standalone .prg file, its content format is the same.

Using the Specification (Reading and Writing PRG Files)

From a developer’s perspective, the PRG format is straightforward to implement:
	•	Reading a PRG: To read or inspect a PRG file, you should first read the first two bytes to obtain the 16-bit load address (remembering that it’s little-endian). For example, bytes $AA $BB would combine to form address $BBAA. This tells you, and any C64 loader, where the following data wants to reside in memory ￼. You can then load the rest of the file bytes and, if you are simulating or emulating, place them in a memory array starting at that address. If you are writing a tool to show details of the PRG (as in a remote-control or UI scenario), you would likely display the load address (in hex, as $xxxx) and perhaps the size of the program data. With a bit more analysis, you could infer the type of program: for instance, a load address of $0801 and the presence of valid BASIC line-link pointers in the first few bytes of data suggests it’s a BASIC program, whereas a load address elsewhere (or nonsensical BASIC pointers) implies a machine code program. The spec itself doesn’t require you to do this, but these are typical use-case details. Importantly, if your tool encounters the ASCII string “C64File” at the start of a file, that’s a signal it’s actually a P00 (or related) container. In that case, you should parse the 26-byte header: skip the magic, retrieve the original filename (bytes $08-$18) if needed for display, skip the record size byte, and then proceed to read the program data starting at byte $1A as if it were a normal PRG ￼. After that point, everything works the same – you’ll get the load address at offset $1A-$1B and so on.
	•	Writing/Producing a PRG: To create a PRG file (for example, from an assembler or an IDE’s build output), you need to decide the load address for your program and prepend it to your binary. In practice, many cross-assemblers offer an option to output a PRG header automatically (for instance, they might have an output mode that writes the start address bytes) ￼. If not, you can do it manually: take your desired start address (e.g. $1000) and write it as two bytes (low byte first, then high byte). Then append the raw machine code bytes or BASIC program bytes that should reside at that address. The resulting file will be immediately loadable in an emulator or on a C64 (with LOAD"PROGRAM",8,1). Make sure the address you choose and the length of your data do not conflict with C64 memory constraints (for example, if you start at $C000 and have 8 KB of data, it will extend to $E000; this is fine as long as it doesn’t unintentionally overlap I/O or ROM areas unless deliberately placed there). If your development toolchain produces a plain binary without the 2-byte header, simply remember to add the header to make it a proper PRG. Conversely, if you want to generate a .P00 instead (which is less common today, but possible), you would create the 26-byte header as described above: write "C64File"+0, write the PETSCII name padded to 16 bytes plus 0 terminator, write record size (0 or appropriate), then write the program (with its own 2-byte load address included) after that. In general, unless you specifically need the PC64 format, sticking to raw .PRG is simpler.

Conclusion

In summary, the Commodore 64’s PRG format is a minimalistic and language-agnostic file format: 2 bytes for the load address, followed by a contiguous block of memory data ￼. This simplicity is what makes it easy to handle in any modern language or tool – no complex parsing is required beyond reading an integer and copying bytes. The key details to remember are the little-endian order of the address and the fact that those address bytes are not part of the memory image itself, but rather an instruction to the loader ￼. Variants like .P00 add a small header mainly for compatibility and metadata, but ultimately deliver the same core data (including the PRG’s own header) to the machine ￼ ￼. By following this specification, you can confidently read PRG files to extract their load address and contents, or produce valid PRG files from raw binaries, ensuring they will run on real C64 hardware and emulators alike.

Sources: The above information was compiled from C64 documentation and community resources, including emulator manuals and format descriptions ￼ ￼ ￼ ￼ ￼, to provide a comprehensive specification of the PRG file format and its common variants. All bytes and fields have been described in detail to facilitate implementation in any programming language.
